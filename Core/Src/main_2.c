// Includes
#include "main.h"

// Defines
#define HOVER_SERIAL_BAUD   115200      // [-] Baud rate for HoverSerial (used to communicate with the hoverboard)
#define START_FRAME         0xABCD     	// [-] Start frame definition for reliable serial communication
#define TIME_SEND           100         // [ms] Sending time interval
#define SPEED_MAX_TEST      300         // [-] Maximum speed for testing
#define SPEED_STEP          20          // [-] Speed step

// UART handle
UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;

// Global variables
uint8_t idx = 0;                        // Index for new data pointer
uint16_t bufStartFrame;                 // Buffer Start Frame
uint8_t *p;                             // Pointer declaration for the new received data
uint8_t incomingByte;
uint8_t incomingBytePrev;

typedef struct{
   uint16_t start;
   int16_t  steer;
   int16_t  speed;
   uint16_t checksum;
} SerialCommand;
SerialCommand Command;

typedef struct{
   uint16_t start;
   int16_t  cmd1;
   int16_t  cmd2;
   int16_t  speedR_meas;
   int16_t  speedL_meas;
   int16_t  batVoltage;
   int16_t  boardTemp;
   uint16_t cmdLed;
   uint16_t checksum;
} SerialFeedback;
SerialFeedback Feedback;
SerialFeedback NewFeedback;

// Function prototypes
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);
void Send(int16_t uSteer, int16_t uSpeed);
void Receive(void);

unsigned long iTimeSend = 0;
int iTest = 0;
int iStep = SPEED_STEP;

// Main function
int main(void)
{
  // Reset of all peripherals, Initializes the Flash interface and the Systick.
  HAL_Init();

  // Configure the system clock
  SystemClock_Config();

  // Initialize all configured peripherals
  MX_GPIO_Init();
  MX_USART1_UART_Init();
  MX_USART2_UART_Init();

  // Start the hoverboard UART
  HAL_UART_Receive_IT(&huart2, &incomingByte, 1);

  while (1)
  {
    unsigned long timeNow = HAL_GetTick();

    // Check for new received data
    Receive();

    // Send commands
    if (iTimeSend > timeNow) continue;
    iTimeSend = timeNow + TIME_SEND;
    Send(0, iTest);

    // Calculate test command signal
    iTest += iStep;

    // Invert step if reaching limit
    if (iTest >= SPEED_MAX_TEST || iTest <= -SPEED_MAX_TEST)
      iStep = -iStep;

    // Blink the LED
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, (timeNow % 2000) < 1000 ? GPIO_PIN_SET : GPIO_PIN_RESET);
  }
}

// Send command function
void Send(int16_t uSteer, int16_t uSpeed)
{
  // Create command
  Command.start    = (uint16_t)START_FRAME;
  Command.steer    = (int16_t)uSteer;
  Command.speed    = (int16_t)uSpeed;
  Command.checksum = (uint16_t)(Command.start ^ Command.steer ^ Command.speed);

  // Write to Serial
  HAL_UART_Transmit(&huart2, (uint8_t *) &Command, sizeof(Command), HAL_MAX_DELAY);
}

// Receive data function
void Receive(void)
{
  // Implementation of the receive function
  // You can use HAL_UART_Receive_IT or HAL_UART_Receive_DMA for receiving data
  // and implement a callback function to process the received data.
}

// System Clock Configuration
void SystemClock_Config(void)
{
  // Implementation of system clock configuration
  // This can be auto-generated by STM32CubeMX
}

// USART1 Initialization Function
static void MX_USART1_UART_Init(void)
{
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
}

// USART2 Initialization Function
static void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
}

// GPIO Initialization Function
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  // GPIO Ports Clock Enable
  __HAL_RCC_GPIOC_CLK_ENABLE();

  // Configure GPIO pin Output Level
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);

  // Configure GPIO pin : PC13
  GPIO_InitStruct.Pin = GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
}

// Error Handler function
void Error_Handler(void)
{
  while(1)
  {
    // Stay here
  }
}

